
This program, scheduler.py, allows you to see how different schedulers perform
under scheduling metrics such as response time, turnaround time, and total
wait time. Three schedulers are "implemented": FIFO, SJF, and RR.
这个程序scheduler.py允许您查看不同的调度程序的执行情况
在诸如响应时间、周转时间和总量等调度指标下的
等待时间。“实现”了三个调度器:FIFO、SJF和RR。

There are two steps to running the program.
运行这个程序有两个步骤。

First, run without the -c flag: this shows you what problem to solve without
revealing the answers. For example, if you want to compute response,
turnaround, and wait for three jobs using the FIFO policy, run this:
首先，不带-c标志运行:这将显示不需要解决什么问题
揭晓答案。例如，如果你想计算响应，
然后等待三个使用FIFO策略的作业，执行以下命令:

  ./scheduler.py -p FIFO -j 3 -s 100

If that doesn't work, try this:
如果这行不通，试试这个:
  python ./scheduler.py -p FIFO -j 3 -s 100

This specifies the FIFO policy with three jobs, and, importantly, a specific
random seed of 100. If you want to see the solution for this exact problem,
you have to specify this exact same random seed again. Let's run it and see
what happens. This is what you should see:
这指定了具有FIFO策略的三个作业，重要的是，还指定了一个特定的
随机抽取100个种子。如果你想知道这个问题的答案，
你必须再次指定这个完全相同的随机种子。让我们运行一下看看
会发生什么。这是你应该看到的:

prompt> ./scheduler.py -p FIFO -j 3 -s 100
ARG policy FIFO
ARG jobs 3
ARG maxlen 10
ARG seed 100

Here is the job list, with the run time of each job: 
  Job 0 (length = 1)
  Job 1 (length = 4)
  Job 2 (length = 7)

Compute the turnaround time, response time, and wait time for each job.  When
you are done, run this program again, with the same arguments, but with -c,
which will thus provide you with the answers. You can use -s <somenumber> or
your own job list (-l 10,15,20 for example) to generate different problems for
yourself.
计算每个作业的周转时间、响应时间和等待时间。当
程序完成后，再次运行这个程序，使用相同的参数，但是使用-c参数，
这样你就能得到答案。你可以使用-s <somenumber>;或
你自己的工作列表(-l 10,15,20为例)来生成不同的问题。

As you can see from this example, three jobs are generated: job 0 of length 1,
job 1 of length 4, and job 2 of length 7. As the program states, you can now
use this to compute some statistics and see if you have a grip on the basic
concepts.
从这个例子中可以看到，生成了三个作业:长度为1的作业0，
长度为4的作业1，长度为7的作业2。如程序所示，你现在可以
用它来计算一些统计数据，看看你是否掌握了基本知识概念。

Once you are done, you can use the same program to "solve" the problem and see
if you did your work correctly. To do so, use the "-c" flag. The output:
一旦你完成了，你可以使用相同的程序来“解决”这个问题，看看
如果你没做错的话。为此，使用“-c”标志。输出:

prompt> ./scheduler.py -p FIFO -j 3 -s 100 -c
ARG policy FIFO
ARG jobs 3
ARG maxlen 10
ARG seed 100

Here is the job list, with the run time of each job: 
  Job 0 (length = 1)
  Job 1 (length = 4)
  Job 2 (length = 7)

** Solutions **
** 解决方案 **

Execution trace:
  [time   0] Run job 0 for 1.00 secs (DONE)
  [time   1] Run job 1 for 4.00 secs (DONE)
  [time   5] Run job 2 for 7.00 secs (DONE)

Final statistics:
  Job   0 -- Response: 0.00  Turnaround 1.00  Wait 0.00
  Job   1 -- Response: 1.00  Turnaround 5.00  Wait 1.00
  Job   2 -- Response: 5.00  Turnaround 12.00  Wait 5.00

  Average -- Response: 2.00  Turnaround 6.00  Wait 2.00

As you can see from the figure, the -c flag shows you what happened. Job 0 ran
first for 1 second, Job 1 ran second for 4, and then Job 2 ran for 7
seconds. Not too hard; it is FIFO, after all! The execution trace shows these
results.
从图中可以看到，-c标志显示了发生了什么。作业0第一个运行
是1秒，作业1第2个运行是4秒，作业2第3个运行是7秒秒。
不太难;毕竟这是先进先出!执行跟踪将显示这些内容结果。

The final statistics are useful too: they compute the "response time" (the
time a job spends waiting after arrival before first running), the "turnaround
time" (the time it took to complete the job since first arrival), and the
total "wait time" (any time spent ready but not running). The stats are shown
per job and then as an average across all jobs. Of course, you should have
computed these things all before running with the "-c" flag!
最后的统计数据也很有用:
它们计算“响应时间”(任务到达后在第一次运行前花费的等待时间)，
“周转时间”(从第一次到达到完成工作所花费的时间)，
总“等待时间”(准备就绪但未运行的时间)。
如下所示，每个工作的数据，然后是所有工作的平均值。
当然，你应该在运行“-c”标志之前计算了所有这些东西!

If you want to try the same type of problem but with different inputs, try
changing the number of jobs or the random seed or both. Different random seeds
basically give you a way to generate an infinite number of different problems
for yourself, and the "-c" flag lets you check your own work. Keep doing this
until you feel like you really understand the concepts.
如果你想尝试相同类型的问题，但输入不同，那就试试
改变作业或随机种子的数量，或两者都改变。不同的随机种子
基本上给了你一种产生无数不同问题的方法
“-c”标志允许您检查自己的工作。继续这样做
直到你觉得你真正理解了这些概念。

One other useful flag is "-l" (that's a lower-case L), which lets you specify
the exact jobs you wish to see scheduled. For example, if you want to find out
how SJF would perform with three jobs of lengths 5, 10, and 15, you can run:
另一个有用的标志是“-l”(这是一个小写的L)，它允许您指定
您希望看到的日程安排的确切工作。比如，如果你想知道
SJF如何执行三个长度为5、10和15的作业，你可以运行:

prompt> ./scheduler.py -p SJF -l 5,10,15
ARG policy SJF
ARG jlist 5,10,15

Here is the job list, with the run time of each job: 
  Job 0 (length = 5.0)
  Job 1 (length = 10.0)
  Job 2 (length = 15.0)
...

And then you can use -c to solve it again. Note that when you specify the
exact jobs, there is no need to specify a random seed or the number of jobs:
the jobs lengths are taken from your comma-separated list.
然后你可以用-c来解。
请注意，确切的作业不需要指定一个随机种子或作业 数量:
作业长度取自逗号分隔的列表。

Of course, more interesting things happen when you use SJF (shortest-job
first) or even RR (round robin) schedulers. Try them and see!
当然，当您使用SJF(最短作业)时，会发生更有趣的事情
或者RR(轮询)调度程序。试试吧!

And you can always run 
  ./scheduler.py -h 

to get a complete list of flags and options (including options such as setting
the time quantum for the RR scheduler).
获取标志和选项的完整列表(包括设置RR调度器的时间量等选项)。